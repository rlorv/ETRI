import sys
import os
from PySide6.QtCore import Qt, Signal, QTimer, QRect, QPoint
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
    QFileDialog, QScrollArea, QMessageBox, QLabel, QGridLayout, QFrame, QSizePolicy
)
from PySide6.QtGui import QPixmap, QPainter, QPen


class ConditionMapViewer(QWidget):

    def get_autosave_path(self):
        base = os.path.basename(self.condition_map_path)
        name, _ = os.path.splitext(base)
        return f"{name}_autosave_matches.json"

    def __init__(self, condition_map_path, zoom_in_paths):
    
        # Initialization 
        super().__init__() # call __init__() of parent class: QWidget 
    
        # Set Widget states 
        self.setFocusPolicy(Qt.StrongFocus) # Keyboard focus: receive Tab & mouse click
        self.setWindowTitle("Condition Map Viewer")
        self.setGeometry(150, 150, 1200, 900)

        # Initializat member variables 
        self.condition_map_path = condition_map_path
        self.zoom_in_paths = zoom_in_paths
        self.matches = {}
        self.match_history = []
        self.redo_stack = []

        # Member variables related to matching procedure. 
        self.selected_zoom_index = None
        self.temp_rect_start = None
        self.temp_rect_end = None
        
        # --- Layout Setup ---
        main_layout = QHBoxLayout(self)

        # Left Side: Vertical buttons
        left_layout = QVBoxLayout()
        self.match_button = QPushButton("Match")
        self.matchStart_button = QPushButton("Match Start")
        self.matchDone_button = QPushButton("Match Done")
        self.export_button = QPushButton("Export Matches")
        self.import_button = QPushButton("Import Matches")
        self.clear_button = QPushButton("Clear All Matches")
        self.undo_button = QPushButton("Undo Last Match")
        self.redo_button = QPushButton("Redo")
        self.help_button = QPushButton("Help")
        self.reset_help_button = QPushButton("Reset Help Flag")

        for btn in [self.match_button, self.matchDone_button, self.matchStart_button, 
                    self.export_button, self.import_button, self.clear_button, 
                    self.undo_button, self.redo_button, self.help_button, 
                    self.reset_help_button]:
            left_layout.addWidget(btn)
        left_layout.addStretch()

        # Connect buttons
        self.match_button.clicked.connect(self.match_selection)
        self.matchStart_button.clicked.connect(self.match_start)
        self.matchDone_button.clicked.connect(self.match_done)

        self.export_button.clicked.connect(self.export_matches)
        self.import_button.clicked.connect(self.import_matches)
        self.clear_button.clicked.connect(self.clear_matches)
        self.undo_button.clicked.connect(self.undo_last_match)
        self.redo_button.clicked.connect(self.redo_match)
        self.help_button.clicked.connect(self.show_help)
        self.reset_help_button.clicked.connect(self.reset_help_flag)

        # Right Side: Map on top, thumbnails on bottom
        right_layout = QVBoxLayout()

        # Condition map display
        self.map_label = QLabel()
        self.map_pixmap = QPixmap(self.condition_map_path)
        scaled_map = self.map_pixmap.scaledToHeight(500, Qt.SmoothTransformation)
        self.map_label.setPixmap(scaled_map)
        self.map_label.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        
        # This block of code overrides default mouse and paint behavior for self.map_label, 
        # which is the QLabel displaying the condition map image.
        self.map_label.mousePressEvent = self.start_rect
        # self.map_label.mouseReleaseEvent = self.end_rect

        self.map_label.setMouseTracking(True)
        self.map_label.mouseMoveEvent = self.track_rect




        # Status traced: Initially set to False. Once clicked, has the value True
        self.mouse_clicked = False
        self.matching_mode = False



        self.map_label.mouseDoubleClickEvent = self.click_region
        self.map_label.paintEvent = self.paint_overlay
        
        right_layout.addWidget(self.map_label)

        # Scroll area with zoom-in thumbnails
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.zoom_widget = QWidget()
        self.zoom_layout = QHBoxLayout()
        self.zoom_layout.setSpacing(5)
        self.zoom_widget.setLayout(self.zoom_layout)
        self.scroll_area.setWidget(self.zoom_widget)
        right_layout.addWidget(self.scroll_area)

        # Build zoom thumbnails
        self.zoom_labels = []
        for i, path in enumerate(self.zoom_in_paths):
            container = QVBoxLayout()
            wrapper = QWidget()
            label = QLabel()
            thumb = QPixmap(path).scaled(120, 120, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            label.setPixmap(thumb)
            label.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
            label.setFrameStyle(QFrame.Panel | QFrame.Raised)
            '''
            Draws a 3D-style panel border around the thumbnail label, making it look 
            raised and clickable.
            '''
            
            label.setLineWidth(2)
            '''
             Makes the border (defined via setFrameStyle) visibly 2 pixels thick, 
             giving the thumbnail a more defined, clickable appearance.
            '''

            label.mousePressEvent = lambda event, idx=i: self.select_zoom(idx)
            name_label = QLabel(os.path.basename(path))
            name_label.setAlignment(Qt.AlignCenter)
            name_label.setFixedWidth(120)
            
            container.addWidget(label)
            container.addWidget(name_label)
            
            wrapper.setLayout(container)
            self.zoom_layout.addWidget(wrapper)
            self.zoom_labels.append(label)

        # Combine layouts
        main_layout.addLayout(left_layout)
        main_layout.addLayout(right_layout)

    '''
    Precondition : index identifies selected subimage. 
    Postcondition: self.selected_zoom_index is set to index. 
    '''
    def select_zoom(self, index):
        
        # Scroll to selected zoom image
        if index < len(self.zoom_labels):
            # Ensures that the given index is within the range of available thumbnails.
            target_widget = self.zoom_labels[index]
            # Retrieves the thumbnail widget for the selected zoom-in image.
            scroll_bar = self.scroll_area.horizontalScrollBar()
            # Gets the horizontal scrollbar associated with the QScrollArea.
            target_x = target_widget.x()
            # This is how far the thumbnail is from the left edge of its container.
            scroll_bar.setValue(target_x)
            # Sets the scroll bar's value so that the selected thumbnail becomes 
            # visible on the left.

        self.selected_zoom_index = index
        # Stores the currently selected thumbnail's index. This is used later by 
        # other methods (e.g. match_selection) to know which zoom-in image is 
        # being matched.

        for i, label in enumerate(self.zoom_labels):
            label.setStyleSheet("border: 2px solid red;" if i == index else "")
        
        # Loops through all thumbnail QLabels. If the thumbnail's index i matches 
        # the selected one, it gets a red border. Otherwise, its border is cleared 
        # ("").

        self.update()
        # Requests a redraw of the widget. Ensures the GUI reflects the updated
        # selection (especially the condition map overlay).

    '''
    Precondition : self.selected_zoom_index must have been set. 
    Postcondition: self.temp_rect_start is set. 
    '''
    def start_rect(self, event):
        if self.selected_zoom_index is None:
            return
        if self.matching_mode == True: 
            if self.mouse_clicked == False: 
                self.temp_rect_start = event.position().toPoint()
                self.mouse_clicked = True
            else:
                self.mouse_clicked = False
                self.temp_rect_end = event.position().toPoint()
                self.update()
        else: 
            pass 

    ''' 
    def end_rect(self, event):
        if self.selected_zoom_index is None:
            return
        self.temp_rect_end = event.position().toPoint()
        self.update()
    '''

    def track_rect(self, event):
        if self.selected_zoom_index is None or self.temp_rect_start is None:
            return
        
        if self.matching_mode == True: 
            if self.mouse_clicked == True: 
                self.temp_rect_end = event.position().toPoint()
                self.update()

    def match_start(self): 
        self.matching_mode = True 

    def match_done(self): 
        self.matching_mode = False

    def match_selection(self):
        if self.selected_zoom_index is None or not self.temp_rect_start or not self.temp_rect_end:
            QMessageBox.warning(self, "Warning", "Please select a zoom-in and draw a region on the map.")
            return
        rect = QRect(self.temp_rect_start, self.temp_rect_end).normalized()
        if self.selected_zoom_index in self.matches:
            self.match_history.append((self.selected_zoom_index, self.matches[self.selected_zoom_index]))
        else:
            self.match_history.append((self.selected_zoom_index, None))
        self.matches[self.selected_zoom_index] = rect
        self.temp_rect_start = self.temp_rect_end = None
        self.update()

    def click_region(self, event):
        self.matching_mode = False
        pos = event.position().toPoint()
        for idx, rect in self.matches.items():
            if rect.contains(pos):
                self.select_zoom(idx)
                break

    def export_matches(self):
        import json
        export_data = {}
        for idx, rect in self.matches.items():
            export_data[os.path.basename(self.zoom_in_paths[idx])] = {
                "x": rect.x(),
                "y": rect.y(),
                "width": rect.width(),
                "height": rect.height()
            }
        save_path, _ = QFileDialog.getSaveFileName(self, "Save Match Data", "matches.json", "JSON Files (*.json)")
        if save_path:
            print(f"[Export] Match data saved to: {save_path}")
            with open(save_path, 'w') as f:
                json.dump(export_data, f, indent=4)
            QMessageBox.information(self, "Exported", f"Match data saved to:{save_path}")

    def import_matches(self):
        import json
        load_path, _ = QFileDialog.getOpenFileName(self, "Load Match Data", "", "JSON Files (*.json)")
        if load_path and os.path.exists(load_path):
            print(f"[Import] Loading match data from: {load_path}")
            
            with open(load_path, 'r') as f:
                data = json.load(f)
            for filename, rect in data.items():
                try:
                    index = next(i for i, path in enumerate(self.zoom_in_paths) if os.path.basename(path) == filename)
                    self.matches[index] = QRect(rect["x"], rect["y"], rect["width"], rect["height"])
                except StopIteration:
                    continue
            self.update()

    def closeEvent(self, event):
        self.save_autosave()
        QMessageBox.information(self, "Autosave", f"Match data autosaved to: {self.get_autosave_path()}")
        event.accept()

    def save_autosave(self):
        print("[Autosave] Saving match data...")
        autosave_path = self.get_autosave_path()
        import json
        data = {}
        for idx, rect in self.matches.items():
            data[os.path.basename(self.zoom_in_paths[idx])] = {
                "x": rect.x(), "y": rect.y(), "width": rect.width(), "height": rect.height()
            }
        print(f"[Autosave] Path: {autosave_path}")
        with open(autosave_path, 'w') as f:
            json.dump(data, f, indent=2)

    def should_show_help(self):
        flag_path = self.get_autosave_path().replace(".json", "_help_shown.flag")
        return not os.path.exists(flag_path)

    def mark_help_shown(self):
        flag_path = self.get_autosave_path().replace(".json", "_help_shown.flag")
        with open(flag_path, 'w') as f:
            f.write("shown")

    def load_autosave(self):
        autosave_path = self.get_autosave_path()
        import json
        if not os.path.exists(autosave_path):
            return
        with open(autosave_path, 'r') as f:
            data = json.load(f)
        for fname, rect in data.items():
            try:
                idx = next(i for i, path in enumerate(self.zoom_in_paths) if os.path.basename(path) == fname)
                loaded_rect = QRect(rect["x"], rect["y"], rect["width"], rect["height"])
                map_rect = self.map_label.pixmap().rect()
                if map_rect.contains(loaded_rect):
                    self.matches[idx] = loaded_rect
                else:
                    print(f"[Import Warning] Ignored out-of-bounds rect for '{filename}': {loaded_rect}")
            except StopIteration:
                continue

    def clear_matches(self):
        confirm = QMessageBox.question(
            self,
            "Confirm Clear",
            "Are you sure you want to clear all matches?",
            QMessageBox.Yes | QMessageBox.No
        )
        if confirm == QMessageBox.Yes:
            self.matches.clear()
            self.update()

    def undo_last_match(self):
        print("[Undo] Attempting to undo last match...")
        if not self.match_history:
            QMessageBox.information(self, "Undo", "No actions to undo.")
            return
        idx, previous_rect = self.match_history.pop()
        current_rect = self.matches.get(idx)
        self.redo_stack.append((idx, current_rect))
        if previous_rect is None:
            self.matches.pop(idx, None)
        else:
            self.matches[idx] = previous_rect
        self.update()

    def redo_match(self):
        print("[Redo] Attempting to redo last undone match...")
        if not self.redo_stack:
            QMessageBox.information(self, "Redo", "No actions to redo.")
            return
        idx, rect = self.redo_stack.pop()
        self.match_history.append((idx, self.matches.get(idx)))
        self.matches[idx] = rect
        self.update()

    def keyPressEvent(self, event):
        if not self.shortcut_keys_enabled:
            return
        if event.modifiers() == Qt.ControlModifier and event.key() == Qt.Key_Z:
            self.undo_last_match()
        elif event.modifiers() == Qt.ControlModifier and event.key() == Qt.Key_Y:
            self.redo_match()

    def reset_help_flag(self):
        flag_path = self.get_autosave_path().replace(".json", "_help_shown.flag")
        if os.path.exists(flag_path):
            os.remove(flag_path)
            print(f"[Reset] Help flag removed at: {flag_path}")
            QMessageBox.information(self, "Reset", f"Help flag has been reset: {flag_path}")
        else:
            print(f"[Reset] No help flag found. Expected: {flag_path}")
            QMessageBox.information(self, "Reset", f"Help flag was not set. Expected path: {flag_path}")

    def show_help(self):
        QMessageBox.information(
            self,
            "Help",
            "".join([
                "Instructions:",
                "1. Select a zoom-in image by clicking a thumbnail.",
                "2. Drag on the condition map to assign its position.",
                "3. Press 'Match' to link it.",
                "4. Double-click on a map region to jump to its thumbnail.",
                "5. Use Ctrl+Z to undo, Ctrl+Y to redo.",
                "6. Use Export/Import to save/load matches.",
                "7. Matches autosave per map file."
            ])
        )

    '''
    
    '''
    def paint_overlay(self, event):
        
        QLabel.paintEvent(self.map_label, event)
        # Ensures that the default label drawing (i.e., the condition map 
        # image itself) happens before your custom overlays. This is important 
        # so the image appears underneath the rectangles.

        painter = QPainter(self.map_label)
        pen = QPen(Qt.red, 2, Qt.SolidLine)
        painter.setPen(pen)
        # QPainter is used to draw shapes directly on the widget. Initially sets 
        # the pen to draw solid red lines with width 2.

        for idx, rect in self.matches.items():
            painter.drawRect(rect)
            # Loops through all matched regions (stored in self.matches) 
            # and draws them as red rectangles.

            if idx == self.selected_zoom_index:
                painter.setPen(QPen(Qt.green, 2, Qt.SolidLine))
                painter.drawRect(rect)
                painter.setPen(QPen(Qt.red, 2, Qt.SolidLine))
            # If this match is the currently selected zoom-in image: It’s drawn 
            # again with a green border. The pen is then reset back to red for 
            # other matches.

        if self.temp_rect_start and self.temp_rect_end:
            rect = QRect(self.temp_rect_start, self.temp_rect_end).normalized()
            painter.setPen(QPen(Qt.blue, 2, Qt.DashLine))
            painter.drawRect(rect)

        # If a temporary rectangle is being defined by the user (between two mouse 
        # clicks): A dashed blue rectangle is drawn to show the selection in progress.

        painter.end()
        # Always required to properly finish painting.

class ClickableLabel(QLabel):
    clicked = Signal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WA_Hover, True)
    
    def mousePressEvent(self, event):
        self.clicked.emit()
        super().mousePressEvent(event)
"""
Member Functions: 
 __init__(self)
 open_images(self)
 load_images(self, filenames)
 set_as_condition_map(self)
 set_as_zoom_in(self)
 re_layout_images(self)
 select_image(self, label):
 update_selection_style(self)
 move_left(self)
 move_right(self)
 delete_image(self)
 save_images(self)
 view_condition_map(self)
"""
class ImageViewerApp(QWidget):

    """
    Precondition : 
    Postcondition: 
    """
    def __init__(self):
        
        """
        Call parent's init() function and set title and geometry of the
        window. 
        """
        super().__init__()
        self.setWindowTitle("Image Viewer")
        self.setGeometry(100, 500, 1000, 600)
        
        # Store loaded image file names (if needed) and 
        # clickable labels.
        self.image_files = []
        self.image_labels = []   # Maintains order of displayed images.

        self.image_categories = {}  # Maps index to "condition_map" or "zoom_in"        
                
        # Default maximum size for each image.
        self.image_scale = 300
        
        self.selected_indices = []  # Instead of self.selected_index
        self.last_selected_index = None  # For shift-selection reference

        # --- LEFT SIDE BUTTONS ---
        self.open_button = QPushButton("Open")
        self.save_button = QPushButton("Save")
        self.left_arrow = QPushButton("←")
        self.right_arrow = QPushButton("→")
        self.delete_button = QPushButton("Delete")
        self.condition_map_button = QPushButton("Set as Condition Map")
        self.zoom_in_button = QPushButton("Set as Zoom-in Cut")
        self.view_map_button = QPushButton("View Condition Map")
        
        # Slots
        self.open_button.clicked.connect(self.open_images)
        self.save_button.clicked.connect(self.save_images)  
        self.left_arrow.clicked.connect(self.move_left)
        self.right_arrow.clicked.connect(self.move_right)
        self.delete_button.clicked.connect(self.delete_image)
        self.condition_map_button.clicked.connect(self.set_as_condition_map)
        self.zoom_in_button.clicked.connect(self.set_as_zoom_in)
        self.view_map_button.clicked.connect(self.view_condition_map)

        # Layout 
        left_layout = QVBoxLayout()
        left_layout.addWidget(self.open_button)
        left_layout.addWidget(self.save_button)
        left_layout.addWidget(self.left_arrow)
        left_layout.addWidget(self.right_arrow)
        left_layout.addWidget(self.delete_button)
        left_layout.addWidget(self.condition_map_button)
        left_layout.addWidget(self.zoom_in_button)
        left_layout.addWidget(self.view_map_button)
        left_layout.addStretch()
        
        # --- RIGHT SIDE: Scroll area with grid layout for images ---
        self.image_widget = QWidget()
        self.image_layout = QGridLayout()
        self.image_widget.setLayout(self.image_layout)
        
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setWidget(self.image_widget)
        
        # --- MAIN LAYOUT ---
        main_layout = QHBoxLayout()
        main_layout.addLayout(left_layout)
        main_layout.addWidget(self.scroll_area)
        self.setLayout(main_layout)

    def get_data(self): 
        pass
    
    def set_data(self, data): 
        print(data)
        pass

    def open_images(self):
        
        """Opens a file dialog to select one or more image files."""
        file_names, _ = QFileDialog.getOpenFileNames(
            self,
            "Select Images",
            "",
            "Images (*.png *.jpg *.jpeg *.bmp *.gif)"
        )

        if file_names:
            self.image_files = file_names
            self.load_images(file_names)
    
    def load_images(self, file_names):
        
        """Clears current images and loads the selected images into the grid."""
        
        # 1. Clear the grid layout.
        for i in reversed(range(self.image_layout.count())):

            # self.image_layout.count()
            # 
            # This method returns the total number of items (widgets or 
            # layout items) currently in the grid layout.
            # 
            # range(self.image_layout.count())
            # 
            # This creates a sequence of numbers starting from 0 up to 
            # one less than the count. For example, if there are 5 items, 
            # it creates the sequence [0, 1, 2, 3, 4].
            # 
            # reversed(...)
            # 
            # This takes the sequence generated by range and returns an 
            # iterator that goes through the sequence in reverse order. 
            # For the above example, it would iterate as 4, 3, 2, 1, 0.

            widget = self.image_layout.itemAt(i).widget()
            
            if widget:
                widget.setParent(None)

                # The widget.setParent(None) call is used to detach the 
                # widget from its current parent—in this case, removing 
                # it from the layout and the widget hierarchy. When you 
                # remove a widget from a layout, you often want it to no 
                # longer be managed by its parent so that it no longer 
                # displays and can be garbage collected if there are no 
                # other references to it. Essentially, setting the parent 
                # to None breaks the relationship between the widget and 
                # its container, effectively "orphaning" the widget.

        self.image_labels.clear()

        # The statement self.image_labels.clear() is a call to the list's 
        # clear() method in Python. This method removes all items from the 
        # list, effectively emptying it. In your application, 
        # self.image_labels stores the clickable labels representing the 
        # images currently displayed in the grid layout. Clearing the list 
        # ensures that any previous image references are removed before new 
        # images are loaded, avoiding duplication or outdated entries.

        self.selected_index = None
        
        columns = 3  # Number of columns in the grid.
        row, col = 0, 0
        
        for file in file_names:
            if os.path.exists(file):
                label = ClickableLabel()
                pixmap = QPixmap(file)
                if not pixmap.isNull():
                    scaled_pixmap = pixmap.scaled(
                        self.image_scale, self.image_scale,
                        Qt.KeepAspectRatio, Qt.SmoothTransformation
                    )
                    label.setPixmap(scaled_pixmap)
                    label.setAlignment(Qt.AlignCenter)
                    
                    # Connect the clicked signal to select this image.
                    label.clicked.connect(lambda l=label: self.select_image(l))

                    # Creates an anonymous function that calls self.select_image 
                    # with a specific label as its argument. Here's a breakdown 
                    # of what happens happens：
                    # 
                    # Lambda Function: It's an inline function without a name.
                    # 
                    # Default Parameter (l=label): This captures the current value
                    # of label at the time the lambda is defined. This is crucial 
                    # in loops, ensuring that each lambda remembers its own label 
                    # rather than all referencing the last one created.
                    #
                    # When Called: The lambda takes no arguments (or ignores any 
                    # provided ones) and simply executes self.select_image(l), 
                    # using the captured label.
                    #
                    # This approach ensures that when the label is clicked, the 
                    # correct image (or label) is passed to the select_image method.

                    self.image_labels.append(label)
                    self.image_layout.addWidget(label, row, col)

                    col += 1
                    if col >= columns:
                        col = 0
                        row += 1

        self.image_widget.adjustSize()
        # instructs the widget to recalculate and adjust its size based on the size 
        # hints of its child widgets and its layout. Essentially, it ensures that 
        # the widget's dimensions are updated to fit its current contents. This is 
        # particularly useful after adding or removing widgets, as it allows the 
        # container to "shrink" or "grow" to accommodate changes without leaving 
        # unnecessary blank space or clipping its content.

    def set_as_condition_map(self):
        if not self.selected_indices:
            QMessageBox.information(self, "Info", "No image selected.")
            return
        for i in self.selected_indices:
            self.image_categories[i] = "condition_map"
        self.update_selection_style()

    def set_as_zoom_in(self):
        if not self.selected_indices:
            QMessageBox.information(self, "Info", "No image selected.")
            return
        for i in self.selected_indices:
            self.image_categories[i] = "zoom_in"
        self.update_selection_style()

    def re_layout_images(self):
        # Save current scroll positions.
        v_scroll = self.scroll_area.verticalScrollBar().value()
        h_scroll = self.scroll_area.horizontalScrollBar().value()

        # Clear the grid layout.
        for i in reversed(range(self.image_layout.count())):
            widget = self.image_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)
        columns = 3
        row, col = 0, 0
        for label in self.image_labels:
            self.image_layout.addWidget(label, row, col)
            col += 1
            if col >= columns:
                col = 0
                row += 1
        self.image_widget.adjustSize()
        self.update_selection_style()
        
        # Restore the scroll positions after the event loop processes pending events.
        QTimer.singleShot(0, lambda: (
            self.scroll_area.verticalScrollBar().setValue(v_scroll),
            self.scroll_area.horizontalScrollBar().setValue(h_scroll)
        ))

    def select_image(self, label):
        """Handle Ctrl/Shift click to select images flexibly."""
        try:
            index = self.image_labels.index(label)
        except ValueError:
            return

        modifiers = QApplication.keyboardModifiers()

        if modifiers == Qt.ShiftModifier and self.last_selected_index is not None:
            # Shift-click: select range
            start = min(self.last_selected_index, index)
            end = max(self.last_selected_index, index)
            self.selected_indices = list(range(start, end + 1))

        elif modifiers == Qt.ControlModifier:
            # Ctrl-click: toggle selection
            if index in self.selected_indices:
                self.selected_indices.remove(index)
            else:
                self.selected_indices.append(index)
            # Preserve last anchor point for shift range
            self.last_selected_index = index if self.last_selected_index is None else self.last_selected_index

        else:
            # Regular click: select one
            self.selected_indices = [index]
            self.last_selected_index = index

        self.update_selection_style()
        
    def update_selection_style(self):
        for i, label in enumerate(self.image_labels):
            style = ""
            if i in self.selected_indices:
                style += "border: 2px solid red;"
            if i in self.image_categories:
                category = self.image_categories[i]
                if category == "condition_map":
                    style += "background-color: rgba(0, 128, 255, 40);"
                    label.setToolTip("Condition Map")
                elif category == "zoom_in":
                    style += "background-color: rgba(255, 165, 0, 40);"
                    label.setToolTip("Zoom-in Cut")
            else:
                label.setToolTip("")
            label.setStyleSheet(style)

    def move_left(self):
        """Move multiple selected images one position to the left."""
        if not self.selected_indices:
            QMessageBox.information(self, "Info", "No images selected to move.")
            return

        if 0 in self.selected_indices:
            return  # At least one image is already at the leftmost position

        # Move from left to right (sorted ascending) to avoid overlap
        for index in sorted(self.selected_indices):
            self.image_labels[index], self.image_labels[index - 1] = (
                self.image_labels[index - 1], self.image_labels[index]
            )
            self.image_files[index], self.image_files[index - 1] = (
                self.image_files[index - 1], self.image_files[index]
            )

        # Update selected_indices
        self.selected_indices = [i - 1 for i in self.selected_indices]
        self.last_selected_index = self.selected_indices[-1]
        self.re_layout_images()

    def move_right(self):
        """Move multiple selected images one position to the right."""
        if not self.selected_indices:
            QMessageBox.information(self, "Info", "No images selected to move.")
            return

        if max(self.selected_indices) >= len(self.image_labels) - 1:
            return  # At least one image is already at the rightmost position

        # Move from right to left (sorted descending) to avoid overlap
        for index in sorted(self.selected_indices, reverse=True):
            self.image_labels[index], self.image_labels[index + 1] = (
                self.image_labels[index + 1], self.image_labels[index]
            )
            self.image_files[index], self.image_files[index + 1] = (
                self.image_files[index + 1], self.image_files[index]
            )

        # Update selected_indices
        self.selected_indices = [i + 1 for i in self.selected_indices]
        self.last_selected_index = self.selected_indices[-1]
        self.re_layout_images()

    def delete_image(self):
        """Delete all selected images."""
        if not self.selected_indices:
            QMessageBox.information(self, "Info", "No images are selected for deletion.")
            return

        for index in sorted(self.selected_indices, reverse=True):
            if index < len(self.image_labels):
                del self.image_labels[index]
            if index < len(self.image_files):
                del self.image_files[index]

        self.selected_indices = []
        self.last_selected_index = None
        self.re_layout_images()
        
    def save_images(self):
        """Placeholder for the save functionality."""
        QMessageBox.information(self, "Info", "Save functionality not implemented.")

    def view_condition_map(self):
        condition_maps = [self.image_files[i] for i, cat in self.image_categories.items() if cat == "condition_map"]
        zoom_ins = [self.image_files[i] for i, cat in self.image_categories.items() if cat == "zoom_in"]
        if not condition_maps:
            QMessageBox.information(self, "Info", "Please assign at least one image as 'Condition Map'.")
            return
        self.map_viewer = ConditionMapViewer(condition_maps[0], zoom_ins)
        self.map_viewer.show()

